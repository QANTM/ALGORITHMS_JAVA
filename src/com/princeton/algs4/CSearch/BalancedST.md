# 第 3 章查找



## 3.1 符号表

##### **定义**

符号表是一种存储键值对的数据结构，支持两种操作。最主要的目的就是将一个键和一个值联系起来

> 用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值

- 插入（put）- 即将一组新的健值对存入表中；
- 查找（get）- 即根据给定的键得到相应的值

###### **典型的符号表应用**

| 应用     | 查找的目的         | 键       | 值        |
| -------- | ------------------ | -------- | --------- |
| 字典     | 找出单词的释义     | 单词     | 释义      |
| 图书索引 | 找出相关的页码     | 术语     | 一串页码  |
| 文件共享 | 找到歌曲的下载地址 | 歌曲名   | 计算机 ID |
| 账户管理 | 处理交易           | 账户号码 | 交易详情  |
| 网络搜索 | 找出相关网页       | 关键字   | 网页名称  |
| 编译器   | 找出符号的类型和值 | 变量名   | 类型和值  |

### 3.3.1 API

##### 一种简单的泛型符号表 API（有序符号表）

##### 具体实现中的几个设计决策

- ###### 泛型

- ###### 重复的键

- ###### 空（nu）键

- ###### 空（null）值

- ###### 删除操作

- ###### 便捷方法

- ###### 迭代

- ###### 键的等价性



#### 3.1.2 有序符号表

##### 3.1.2.1 最大键和最小键

- 在队列 Queue 中已经讨论过 `IndexMinPQ()`

- 主要区别：优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作更多。

##### 3.1.2.2 向下取整和向上取整

对于给定的键，向下取整（floor）操作（找出小于等于该键的最大键）和向上取整（ceiling）操作（找出大于等于该键的最小键）有时很有用。

这两个术语来自于实数的取整函数（对一个实数 x 向下取整即为小于等于 x 的最大整数，向上取整则为大于等于 x 的最小整数）

##### 3.1.2.3 排名和选择

检验一个新的键是否插入合适位置的基本操作是

- 排名（rank，找出小于指定键的键的数量）
- 选择（select，找出排名为 k 的键）

要测试一下你是否完全理解了它们的作用，请确认对于 0 到 `size () -1` 的所有 `i` 都有 `i=rank(select(i)))`，且所有的键都满足 `i=select(rank(key))`。

2.5 节中我们在学习排序时已经遇到过对这两种操作的需求了。

对于符号表，我们的挑战是在实现插入、删除和查找的同时快速实现这两种操作。

有序符号表的操作示例如表 3.1.5 所。

##### 3.1.2.4 范围查找

> 给定范围内（在两个给定的键之间）有多少键？是哪些？

在很多应用中能够回答这些问题并接受两个参数的 `size()` 和  `keys()` 方法都很有用，

- 特别是在大型数据库中。能够处理这类查询是有序符号表在实践中被广泛应用的重要原因之一

##### 3.1.2.5 例外情况

当一个方法需要返回一个键但表中却没有合适的键可以返回时，我们约定

- 抛出一个异常

- 另1种合理的方法是在这种情况下返回空

> 例如，在符号表为空时，`min()` 、`max()` 、`deleteMin()`、 `deleteMax()`、`f1oor()`和 `cei1ing()`都会抛出异常，当 `k<0` 或 `k >= size()`时 `select(k)`也会抛出异常。

##### 3.1.2.6 便捷方法

在基础 API 中我们已经见过了 `contains()` 和 `isEmpty(s)`方法，为了用例的清晰我们又在 API 中添加了一些冗余的方法。为了节约版面，除非特别声明，我们约定所有有序符号表 API 的实现都含有如表 3.1.6 所示的方法。

##### 3.1.2.7（再谈）键的等价性

Java 的一条最佳实践就是维护所有 Comparable 类型中 compareTo() 方法和 equals() 方法的一致性。也就是说，任何一种 Comparable 类型的两个值 a 和 b 都要保证 `(a.compareTo(b) ==0)` 和 `a.equals (b)` 的返回值相同。为了避免任何潜在的二义性，我们不会在有序符号表的实现中使用 `equals()`方法。作为替代，我们只会使用 `compareto()` 	方法来比较两个键，即我们用布尔表达式 a compareto (b) ==0 来表示“a 和 b 相等吗？”。一般来说，这样的比较都代表着在符号表中的一次成功査找（找到了 b）。和排序算法一样，Java 为许多经常作为键的数据类型提供了标准的  compareTo() 方法，为你自定义的数据类型实现一个 compareto）方法也不困难（参见 2.5 节）。

##### 3.1.2.8 成本模型

- 比较
  - 我们使用比较一词来表示将一个符号表条目和一个被找的键进行比较操作。
    - 无论我们是使用 equals() 方法（对于符号表的键不是 Comparable 对象而言）
    - 还是 compareTo() 方法（对于符号表的键是 Comparable 对象而言）
  - 在大多数的符号表实现中，这个操作都出现在内循环
- 数组的访问次数统计

**查找的成本模型 ——**

> - 统计比较的次数 ：表示将一个符号表条目和一个被找的键进行比较操作（等价性测试或是键的相互比较）
> - 内循环不进行比较（极少）的情况，我们统计数组的访问次数。

符号表实现的重点在于

- 其中使用的数据结构
- `get()`
- `put()`

为区别不同的实现，我们在特定的符号表实现的类名前加上了描述性前缀

### 3.1.3 用例举例

- 一个用来跟踪算法在小规模输入下的行为测试用例
- 一个用来寻找更高效的实现的性能测试用例。

##### 3.1.3.1 行为测试用例

为了在小规模的输入下跟踪算法的行为，我们用以下测试用例测试我们对符号表的所有实现。这段代码会从标准输入接受多个字符串，构造一张符号表来将和第个字符串相关联，然后打印符号表。

在本书中我们假设所有的字符串都只有一个字母。一般我们会使用“S ARCHE X A

3.1.3.2 性能测试用例

### 3.1.4 无序链表中的顺序查找

### 3.1.5 有序数组中的二分查找

##### 3.1.5.1 二分查找

##### 3.1.5.2 其他操作



### 3.1.6 对二分查找的分析

### 3.1.7 预览

### 答疑