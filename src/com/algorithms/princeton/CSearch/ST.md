# 第 3 章查找



## 3.1 符号表

##### **定义**

符号表是一种存储键值对的数据结构，支持两种操作。最主要的目的就是将一个键和一个值联系起来

> 用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值

- 插入（put）- 即将一组新的健值对存入表中；
- 查找（get）- 即根据给定的键得到相应的值

###### **典型的符号表应用**

| 应用     | 查找的目的         | 键       | 值        |
| -------- | ------------------ | -------- | --------- |
| 字典     | 找出单词的释义     | 单词     | 释义      |
| 图书索引 | 找出相关的页码     | 术语     | 一串页码  |
| 文件共享 | 找到歌曲的下载地址 | 歌曲名   | 计算机 ID |
| 账户管理 | 处理交易           | 账户号码 | 交易详情  |
| 网络搜索 | 找出相关网页       | 关键字   | 网页名称  |
| 编译器   | 找出符号的类型和值 | 变量名   | 类型和值  |

### 3.3.1 API

##### 一种简单的泛型符号表 API（有序符号表）

![1种简单的泛型符号表 API](/Users/zenn/IdeaProjects/ALGORITHMS_JAVA/utils/statics/311一种简单的泛型符号表 API.png)

##### 具体实现中的几个设计决策

- ###### 泛型

- ###### 重复的键

- ###### 空（nu）键

- ###### 空（null）值

- ###### 删除操作

  - 延时删除
  - 即时删除
  - 防御性代码 `if (val == null) { delete(key); return ;}`:保证符号表中任何键的值都不为空

- ###### 便捷方法

  ![默认实现](/Users/zenn/IdeaProjects/ALGORITHMS_JAVA/utils/statics/312默认实现.png)

- ###### 迭代

  为了和以后的有序符号表的所有方法保持一致，使得用例可以遍历表的键集的一个指定的部分。ST 使用了一个更简单的方法：定义了 `keys()` 方法来返回一个 `Interable <Key>` 对象以方便用例遍历所有的键

- ###### 键的等价性

  在 1.2.5.8 节中讨论过

  2.4.4.5 中讨论：最好使用不可变的数据类型作为键，否则表的一致性无法保证。



#### 3.1.2 有序符号表

许多符号表的实现都利用了 `Comparable` 接口带来的键的有序性来更好地实现 `put()` 和 `get()` 方法。我们可以认为符号表都会保持键的有序并大大扩展它的 API，根据键的相对位置定义更多实用的操作。

##### 3.1.2.1 最大键和最小键

- 在队列 Queue 中已经讨论过 `IndexMinPQ()`

- 主要区别：优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作更多。

##### 3.1.2.2 向下取整和向上取整

对于给定的键，向下取整（floor）操作（找出小于等于该键的最大键）和向上取整（ceiling）操作（找出大于等于该键的最小键）有时很有用。

这两个术语来自于实数的取整函数（对一个实数 x 向下取整即为小于等于 x 的最大整数，向上取整则为大于等于 x 的最小整数）

##### 3.1.2.3 排名和选择

检验一个新的键是否插入合适位置的基本操作是

- 排名（rank，找出小于指定键的键的数量）
- 选择（select，找出排名为 k 的键）

要测试一下你是否完全理解了它们的作用，请确认对于 0 到 `size () -1` 的所有 `i` 都有 `i=rank(select(i)))`，且所有的键都满足 `i=select(rank(key))`。

2.5 节中我们在学习排序时已经遇到过对这两种操作的需求了。

对于符号表，我们的挑战是**在实现插入、删除和查找的同时快速实现这两种操作。**

有序符号表的操作示例如表 3.1.5 所。

##### 3.1.2.4 范围查找

> 给定范围内（在两个给定的键之间）有多少键？是哪些？

在很多应用中能够回答这些问题并接受两个参数的 `size()` 和  `keys()` 方法都很有用，

- 特别是在大型数据库中。能够处理这类查询是有序符号表在实践中被广泛应用的重要原因之一

##### 3.1.2.5 例外情况

当一个方法需要返回一个键但表中却没有合适的键可以返回时，我们约定

- 抛出一个异常

- 另1种合理的方法是在这种情况下返回空

> 例如，在符号表为空时，`min()` 、`max()` 、`deleteMin()`、 `deleteMax()`、`f1oor()`和 `cei1ing()`都会抛出异常，当 `k<0` 或 `k >= size()`时 `select(k)`也会抛出异常。

##### 3.1.2.6 便捷方法

在基础 API 中我们已经见过了 `contains()` 和 `isEmpty(s)`方法，为了用例的清晰我们又在 API 中添加了一些冗余的方法。为了节约版面，除非特别声明，我们约定所有有序符号表 API 的实现都含有如表 3.1.6 所示的方法。

##### 3.1.2.7（再谈）键的等价性

Java 的一条最佳实践就是维护所有 `Comparable` 类型中 `compareTo()` 方法和 `equals()` 方法的一致性。

也就是说，任何一种 Comparable 类型的两个值 a 和 b 都要保证 `(a.compareTo(b) == 0)` 和 `a.equals (b)` 的返回值相同。

为了避免任何潜在的二义性，我们不会在有序符号表的实现中使用 `equals()`方法。

作为替代，我们只会使用 `compareto()` 方法来比较两个键，即我们用布尔表达式 `a.compareto (b) == 0 `来表示“a 和 b 相等吗？”。一般来说，这样的比较都代表着在符号表中的一次成功査找（找到了 b）。

和排序算法一样，Java 为许多经常作为键的数据类型提供了标准的  `comareTo()` 方法，为你自定义的数据类型实现一个 `compareto()` 方法也不困难（参见 2.5 节）



##### 3.1.2.8 成本模型

- 比较
  - 我们使用比较一词来表示将一个符号表条目和一个被找的键进行比较操作。
    - 无论我们是使用 equals() 方法（对于符号表的键不是 Comparable 对象而言）
    - 还是 compareTo() 方法（对于符号表的键是 Comparable 对象而言）
  - 在大多数的符号表实现中，这个操作都出现在内循环
- 数组的访问次数统计（少数情况下）

**查找的成本模型 ——**

> - 统计比较的次数 ：表示将一个符号表条目和一个被找的键进行比较操作（等价性测试或是键的相互比较）
> - 内循环不进行比较（极少）的情况，我们统计数组的访问次数。

符号表实现的重点在于

- 其中使用的数据结构
- `get()`
- `put()`

为区别不同的实现，我们在特定的符号表实现的类名前加上了描述性前缀

### 3.1.3 用例举例

- 一个用来跟踪算法在小规模输入下的行为测试用例

- 一个用来寻找更高效的实现的性能测试用例。

  

##### 3.1.3.1 行为测试用例

```Java
public class STBehaviorTest {
    public static void main(String[] args) {
        ST<String, Integer> st;
        st = new ST<String, Integer>();

        for (int i = 0; !StdIn.isEmpty(); i++) {
            String key = StdIn.readString();
            st.put(key, i);
        }

        for (String s : st.keys())
            StdOut.println(s + " " + st.get(s));
    }
}
```

为了在小规模的输入下跟踪算法的行为，我们用以下测试用例测试我们对符号表的所有实现。这段代码会从标准输入接受多个字符串，构造一张符号表来将和第个字符串相关联，然后打印符号表。

在本书中我们假设所有的字符串都只有一个字母。一般我们会使用“S ARCHE X A

##### 3.1.3.2 性能测试用例

- `FrequencyCounter` 用例会从标准输入中得到的一列字符串并记录每个（长度至少达到指定的阈值）字符串的出现次数，然后遍历所有键并找出出现频率最高的键。
- 作为一种代表，有许多其他符号表应用的共性
  - 混合使用查找和插入的操作；
  - 大量的不同键；
  - 査找操作比插入操作多得多；
  - 虽然不可预测，但查找和插入操作的使用模式并非随机。



### 3.1.4 无序链表中的顺序查找

研究最坏情况下的性能，使用“命中”表示一次成功的查找，“未命中”表示一次失败的查找

- 私有 Node 类在链表中保存键和值
- `get()` 实现会顺序搜索链表查找给定的键(找到返回相关联的值), 
- `put()` 实现也会顺序地搜索链表查找给定的键。
- `size()` `keys()` `delete()`方法实现留作练习

> **命题 A**:在含有 N 对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要 N 次比较。命中的查找在最坏情况下需要 N 次比较。特别地，向一个空表中插入 N 个不同的键需要~N*2 次比较。
>
> **证明**：在表中查找一个不存在的键时，我们会将表中的每个键和给定的键比较。因为不允许出现重复的健，每次插入操作之前我们都需要这样查找一遍。
>
> **推论**：向一个空表中插入 N 个不同的健需要 N2 次比较。

基于链表的实现以及顺序查找是非常低效的，无法满足 Frequency-Counter 处理庞大输入问题的需求。

比较的总次数和査找次数与插入次数的乘积成正比。

### 3.1.5 有序数组中的二分查找

数据结构：一对平行的数组，一个存键，一个存值

算法 `BinarySearchST` 可以保证数组中 Comparable 类型的键有序，然后使用数组的索引来高效实现 `get()` 和其他操作。核心是 `rank()` 方法，返回表中小于给定键的数量

留下来了一个练习 `3.1.12` 

##### 3.1.5.1 二分查找

##### 3.1.5.2 其他操作



### 3.1.6 对二分查找的分析

### 3.1.7 预览

### 答疑